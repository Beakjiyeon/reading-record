# 15. 구글 드라이브 설계
# 1단계. 문제 이해 및 설계 범위 확정
- 기능적 요구사항
  - 파일 추가
  - 파일 다운로드
  - 여러 단말에 파일 동기화
  - 파일 갱신 이력 조회
  - 파일 공유
  - 파일 편집, 삭제될 경우 알림
  - 여러 사용자가 같은 문서를 동시에 편집하는 기능은 범위에서 제외한다.
- 비기능적 요구사항
  - 안정성 : 데이터 손실 방지
  - 빠른 동기화 속도
  - 네트워크 대역폭이 너무 커선 안된다.
  - 규모 확장성 : 아주 많은 양의 트래픽 처리 가능해야 함
  - 높은 가용성 : 일부 서버 장애, 느려지거나, 네트워크 일부가 끊겨도 시스템은 계속 사용 가능해야 한다.
- 개략적 추정치
<br/>
  
# 2단계. 개략적 설계안 제시 및 동의 구하기
- 필요한 api
  - 파일 업로드 api : 단순 업로드(파일 크기 작은경우), 이어 올리기(파일이 크거나 네트워크 장애 발생 가능성 있는 경우)
  - 파일 다운로드 api
  - 파일 갱신 히스토리 api
  - 모두 사용자 인증을 필요로 하고 https 프로토콜을 사용해야 한다. 데이터를 보호하기 위함
- 업로드 되는 파일이 많아지면 파일시스템을 가득 차게 되므로 데이터를 여러 서버에 나누어 샤딩(저장)해야 한다.
  - 데이터 다중화를 위해 s3 버킷에 저장한다. 가용성과 데이터 무손실을 보장하기 위해 다중화한다.
- 로드밸런서를 통해 네트워크 트래픽을 분산한다. 또한 특정 웹 서버에 장애가 발생하면 자동으로 해당 서버를 우회해 준다.
- 메타데이터 데이터 베이스 : 데이터베이스를 파일 저장 서버에서 분리하여 싱글 포인트 오브 페일러를 회피한다. 아울러 다중화, 샤딩 정책을 적용하여 가용성과 규모 확장성 요구사항에 대응한다.
- 개략적 설계안 컴포넌트
  - 블록 저장소 서버
    - 파일블록을 클라우드 저장소에 업로드하는 서버다.
    - 파일을 여러 개의 블록으로 나눠 저장하며 각 블록에는 고유한 해시값이 할당된다.
    - 해시 값은 메타데이터 데이스 베이스에 저장된다. 각 블록은 독립적인 객체로 취급되며 s3(클라우드 저장소)에 보관딘다.
  - 아카이빙 저장소 : 오랫동안 사용되지 않은 비활성 데이터를 저장하기 위한 컴퓨터 시스템
  - 로드 밸런서
  - 클라우드 저장소
  - api 서버 : 파일 업로드 외 거의 모든 기능. 사용자 인증, 사용자 프로필 관리, 파일 메타데이터 갱신 등
  - 메타데이터 데이스 베이스 : 사용자, 파일, 블록, 버전 등 정보 관리. 실제 파일은 클라우드에, 이 데이터베이스엔 오직 메타정보만 둔다.
  - 메타데이터 캐시 : 성능을 높이 기 위해 자주 쓰이는 메타 데이터는 캐시한다.
  - 알림 서비스 : 발생/구독 프로토콜 기반 시스템이다.
  - 오프라인 사용자 백업 큐 : 클라이언트가 접속 중이 아니라서 파일의 최신 상태를 확인할 수 없을 땐 해당 정보를 이 큐에 두어 나중에 클라이언트가 접속했을 때 동기화될 수 있도록한다.
<br/>

# 3단계. 상세 설계
### 블록 저장소 서버
- 정기적으로 갱신되는 큰 파일들은 업데이트가 일어날 때마다 전체 파일을 서버로 보내면 네트워크 대역폭을 많이 필요로 하는데 이를 최적화하는 방법 2가지
  - 델타 동기화 : 파일이 수정되면 전체 파일 대신 수정이 일어난 블록만 동기화하는 것
  - 압축 : 블록 단위로 압축해 두면 데이터 크기를 많이 줄일 수 있다.
- 블록 저장소 서버는 파일 업로드에 관계된 일을 처리한다.
- 클라이언트가 보낸 파일을 블록단위로 나눈다.
- 각 블록에 압축 알고리즘, 암호화를 적용한다.
- 전체 파일을 저장소 시스템을 보내는 대신 수정된 블록만 전송해야 한다.
<br/>

### 높은 일관성 요구사항
- 강한 일관성 모델을 지원해야 한다.
- 메모리 캐시는 보통 최종 일관성 모델을 지원하는데 강한 일관성을 달성하려면 아래를 만족해야 한다.
  - 캐시에 보관된 사본과 데이터베이스는 원본이 일치한다.
  - 데이터베이스에 보관된 원본에 변경이 발생하면 캐시에 있는 사본을 무효화 한다.
  - nosql 데이터베이스는 acid 를 기본으로 지원하지 않으므로 강한 일관성을 보장하도록 동기화로직안에 프로그랢을 짜야 한다.
<br/>

### 메타데이터 데이터베이스
- user: 이름, 이메일, 프로필 사진 등
- device : 단말 정보. push_id는 모바일 알림용임
- namespace : 사용자의 루트 디렉터리 정보
- file : 파일의 최신 정보
- file_version : 파일 갱신 이력. 전부 읽기 전용.
- block : 파일 블록에 대한 정보
<br/>

### 업로드 절차
2개의 요청이 병렬적으로 전송된 프로세스
- 파일 메타데이터 추가
  1. 클라이언트 1이 새 파일의 메타데이터를 추가하기 위한 요청 전송
  2. 새 파일의 메타데이터를 데이터베이스에 저장하고 업로드 상태를 대기중으로 변경
  3. 새 파일이 추가되었음을 알림 서비스에 통지
  4. 알림 서비스는 관련된 클라이언트2에게 파일이 업로드 되고 있음을 알림
- 파일을 클라우드 장소에 업로드
  1. 클라이언트1이 파일을 블록 저장소 서버에 업로드
  2. 블록 저장소 서버는 파일을 블록단위로 쪼갠 다음 압축하고 암호화한 다음 클라우드 저장소에 전송
  3. 업로드가 끝나면 클라우드 스토리지는 완료 콜백을 호출하고 이는 api 서버로 전송됨
  4. 메타데이터 db에 기록된 해당 파일의 상태를 완료로 변경
  5. 알림 서비스에 파일 업로드가 끝났음을 통지
  6. 알림 서비스는 관련 클라이언트2에게 파일 업로드가 끝났음을 통지
<br/>

### 다운로드 절차
- 파일이 새로 추가되거나 편집되면 자동으로 다운로닥 시작된다.
- 클라이언트는 다른 클라이언트가 파일을 편집, 추가한 사실을 어떻게 감지하는가
  - 클라이언트 a가 접속중이고 다른 클라이언트가 파일을 변경하면 알림서비스가 클라이언트 a에게 변경알림을 보내가 pull받아야 함을 알림
  - 클라이언트 a가 네트워크 연결된 상태가 아니면 데이터는 캐시에 보관되고 접속했을 때 해당 클라이언트는 새 버전을 가져간다.
1. 알림서비스가 클라이언트 2에게 누군가 파일을 변경함을 알림
2. 알림을 확인한 클라이언트는 새로운 메타 데이터를 요청
3. api 서버는 메타데이터 데이터베이스에게 새 메타데이터 요청
4. api 서버에게 새 메타데이터 반환됨
5. 클라이언트2에게 새 메타데이터 반환됨
6. 클라이언트 2는 블록 다운로드 요청 전송
7. 블록 저장소 서버는 클라우드 저장소에서 블록 다운로드
8. 클라우드 저장소는 블록 서버에 요청된 블록반환
9. 블록 저장소 서버는 클라이언트에게 요청된 블록을 반환.
10. 클라이언트 2는 전송된 블록을 사용하여 파일 재구성
<br/>

### 알림 서비스
- 롱폴링 방식
- 웹소켓 방식
- 양방향 통신이 필요하지 않으므로 롱 폴링 방식 채택
- 각 클라이언트는 알림 서버와 롱 폴링용 연결을 유지하다가 특정 파일에 대한 변경을 감지하면 해당 연결을 끊는다.
- 이 때 클라이언트는 반드시 메타데이터 서버와 연결해 파일의 최신 내역을 다운로드해야 한다.
- 해당 다운로드 작업이 끝났거나 연결 타임아숭이 되면 즉시 새 요청을 보내어 롱 폴링 연결을 복원하고 유지해야 한다.
<br/>

### 저장소 공간 절약
- 파일 갱신 이력을 보존하고 안정성을 보장하기 위해 파일의 여러 버전을 여러 데이터 센터에 보관해야 한다.
- 저장용량 소진 문제를 피하고 비용 절감하기 위한 방법
  - 중복 제거 : 중복된 파일 블록을 계정 차원에서 제거 (해시값 비교)
  - 지능적 백업 전략 도입
    - 한도 설정 : 보관 파일 버전 개수 제한
    - 중요 버전만 보관
  - 자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮긴다. ex. 아미존 s3 글래시어    
<br/>

### 장애 처리
- 로드밸런서 장애 : 부로드밸런서를 호라성화시켜 트래픽을 이어 받아야 함. 
- 블록 저장소 서버 장애 : 다른 서버가 대기 작업을 이어받아야 함
- 클라우드 저장소 장애 : s3 버킷 다중화
- api 서버 장애 : 무상태서버이므로 다른 서버로 해당 트래픽을 보낸다.
- 메타데이터 캐시 장애 : 다중화한다. 
- 메타데이터 데이터베이스 장애 : 주 db 죽으면 부 db 중 골라 주 서버로 바꾸고, 부db 추가. 부 db 가 죽으면 새 것으로 교체
- 알림서비스 장애 : 모든 사용자가 롱폴링 연결을 다시 만들어야 함. 오래 걸림
- 오프라인 사용자 백업 큐 장애 : 다중화. 백업 큐로 구독 관계를 재설정해야 한다. 
<br/>

# 4단계. 마무리
- 높은 수준의 일관성, 낮은 네트워크 지연, 빠른 동기화가 요구됨
- 파일의 메타데이터를 관리하는 부분, 파일 동기화를 처리하는 부분이 주요 구성
- 알림서비스는 롱폴링을 사용하여 클라이언트로 하여금 파일의 상태를 최신으로 유지하도록 한다.
