# 6. 키-값 저장소 설계
### 키-값 저장소란?
- 키-값 저장소에서 키는 유일해야 한다. 
- 키는 일반 텍스트거나 해시 값일 수 있다.
- 키는 짧을 수록 성능이 좋다. 
- 키-값 저장소로 aws 다이나모, memcached, 레디스 등이 널리 알려져 있다.
<br/>

### 단일 서버 키-값 저장소
- 설계 : 키-값 쌍 전부 메모리에 해시 테이블로 저장한다.
  - 장점 : 빠른 속도를 보장한다.
  - 단점 : 모든 데이터를 메모리에 두기 부족할 수 있다.
  - 개선책 : 데이터 압축, 자주 쓰는 데이터만 메모리에 두고 나머지는 디스크에 저장
  - 그러나 많은 데이터를 저장하려면 분산 키-값 저장소를 만들어야 한다.
<br/>

### 분산 키-값 저장소
- 분산 해시 테이블이라고도 불린다.
- 분산 키-값 저장소를 설계할 때는 CAP (일관성, 가용성, 파티션 감내) 정리를 인지해야 한다.
- 통상 네트워크 장애는 피할 수 없으므로 CA 시스템은 존재하지 않는다.
<br/>


## 키-값 저장소 구현에 사용될 핵심 컴포넌트
### 데이터 파티션
- 고려 사항 : 여러 서버에 데이터가 고르게 분산 되는가, 노드 추가/삭제 시 데이터 이동이 최소화되는가
- 안정 해시 기술을 권장한다. 규모 확장 자동화(서버 추가/삭제 용이), 다양성(서버의 용량에 맞게 가상 노드 수 조정 용이)
<br/>


### 데이터 다중화
- 데이터를 다른 곳에 백업하는 것
- 백업할 노드는 다른 지역 데이터 센터에 두고 센터들은 고속 네트워크로 연결한다.
<br/>


### 일관성
- 다중화된 데이터는 적절히 동기화가 필요하다.
- 정족수의 합 프로토콜을 이용하면 된다.
- N(사본 수), W(쓰기 정족 수), R(읽기 정족 수)는 요구되는 일관성 수준에 따라 타협하면 된다.
- 정족수 : 어떤 조건이 성립되려면 적어도 x개의 상황이 발생해야 한다.
- 일관성 모델
  - 일관성의 수준을 결정한다.
  - 강한 일관성 : 모두 가장 최신 데이터 제공. 장애 발생 시 읽기/쓰기를 금지시킨다. 고가용성 만족 안함
  - 약한 일관성 : 읽기 연산은 최신 데이터를 못 받을 수 있다.
  - 최종 일관성 : 약한 일관성의 일종이다. 결국엔 다 보이게 된다. 병렬 쓰기 작업이 있을 경우 클라이언트 단위에서 일관성 깨질 가능성을 막을 수 있다.
<br/>

### 일관성 불일치 해소
- 버저닝 : 데이터를 변경할 때마다 새로운 버전 생성한다. 이전 버전 데이터는 변경이 불가능하다.
- 벡터 시계 : D[서버,버전] 
- 백터 시계를 보고 클라이언트가 일관성 불일치를 파악하는 방법인데, 클라이언트 개발 부담과 백터 시계 순서쌍이 적은 시간에 많이 증가하는 단점이 있다. 임계치를 두고 관리하게 되면 일관성 불일치 해소 효율이 떨어질 수 있다.
<br/>

### 장애 처리
- 장애 감지 
  - 멀티 서버면 n개 서버 모두 장애여야 서비스 장애로 판단한다.
  - 쉬운방법 : 멀티 캐스팅 채널 구축. 서버가 많을 땐 비효율 적이다. 
  - 가십 프로토콜 구축 : 멤버십 목록을 두고 멤버들의 박동 카운트를 1씩 증가시킨다. 증가되지 않은 노드에 대해 모든 노드가 인지하게 되면 장애노드로 처리한다.
- 장애 처리
  - 일시적인 처리 : 엄격한 정족수 접근법은 데이터 읽기/쓰기를 모두 제한한다. 느슨한 정족수 접근법은 읽기, 쓰기 연산을 수행할 w, r개의 서버를 링에서 고른다.  
    - 위탁 기법 : 장애서버로 가는 요청은 다른 서버가 대신 처리하고 힌트를 남겨 장애 복구 뒤 반영한다.
  - 영구적인 처리 : 반엔트로피 프로토콜을 구현한다. 사본과 비교하여 최신 버전으로 동기화한다. 머클 트리를 통해 일관성 없는 상태를 감지하고 전송양을 줄인다. 
  - 데이터 센터 장애 처리 : 데이터를 여러 데이터 센터에 다중화 해야 한다.
<br/>

### 시스템 아키텍처 다이어그램
<img width="247" alt="image" src="https://github.com/Beakjiyeon/reading-record/assets/35768650/75b1a4d9-c1b7-4752-a1f9-b5f2116c9f58">

- 클라이언트는 키-값 저장소가 제공하는 2가지 단순한 api get, put과 통신한다.
- 중재자는 클라이언트에게 키-값 저장소에 대한 프락시 역할을 하는 노드다.
- 노드는 안정 해시의 해시 링 위에 분포한다.
- 노드를 자동으로 추가, 삭제할 수 있도록 시스템은 완전히 분산된다.
- 데이터는 여러 노드에 다중화한다.
- 모든 노드가 같은 책임을 지므로 싱글포인트 오브 페일러는 존재하지 않는다. 
<br/>

### 쓰기 경로
- 쓰기 요청이 커밋 로그에 기록된다.
- 데이터가 메모리 캐시에 기록된다.
- 메모리 캐시가 가득 차거나 사전에 정의된 어떤 임계치에 도달하면 데이터는 디스크에 있는 ssTable에 기록된다. 
<br/>

### 읽기 경로
- 데이터가 메모리 캐시에 있는 지 검사하고 있으면 반환한다.
- 없으면 블룸 필터를 검사한다.
- 블룸 필터를 통해 어떤 ssTable에 키가 보관되어 있는지 알아낸다.
- ssTable에서 데이터를 가져온다.
- 해당 데이터를 클라이언트에게 반환한다.
<br/>


### 요약
<img width="305" alt="image" src="https://github.com/Beakjiyeon/reading-record/assets/35768650/4b78049e-422a-4dd8-9f14-d27f307ab005">
<br/>

### 다시 볼 부분
- p.105 장애 처리 그림 6-10 멀티캐스팅 채널이 뭔지 알아보기
- p.110 장애 처리 머클 트리 부분 다시 읽기
<br/>

