# 13. 검색어 자동완성 시스템
가장 많이 사용된 검색어 k개를 자동완성하여 출력하는 시스템
<br/>

## 1단계. 문제 이해 및 설계 범위 확정
### 기능
- 사용자가 입력하는 단어는 자동완성될 검색어의 첫 부분
- 5개의 자동완성 검색어 제공
- 많이 검색된 순으로
- 맞춤법 검사, 자동 수정은 지원 안함
- 영어. 가능하면 다국어 지원
- 영어 소문자 검색어
- 일간 사용자 천만명
<br/>

### 설계 요구사항
- 빠른 응답 속도 : 시스템 응답 속도는 100밀리초 이내
- 연관성 : 결과가 사용자가 입력한 단어와 연관된 것이어야 함
- 정렬 : 계산은 인기도 등의 순위 모델에 의해 정렬 되어야 한다.
- 규모 확장성 : 많은 트래픽을 감당할 수 있도록 확장 가능해야 한다.
- 고가용성 : 시스템 장애가 발생하거나 느려지거나 네트워크 문제가 생겨도 계속 사용 가능해야 한다.
<br/>


## 2단계. 개략적 설계안 제시 및 동의 구하기
데이터 수집 서비스, 질의 서비스 두 부분으로 나뉜다.
### 데이터 수집 서비스
- 사용자가 입력한 질의를 실시간으로 수집하는 시스템이다.
- 데이터가 많은 애플리케이션엔 바람직하지 않지만 설계안을 만드는 출발점으로는 괜찮다.
- 빈도 테이블 : 질의문과 사용빈도를 저장한다.
<br/>

### 질의 서비스
- 주어진 질의(검색)에 대해 5개의 인기 검색어를 정렬하는 시스템이다.
- 사용자가 검색어를 입력하면 sql top 함수를 통해 빈도 테이블을 조회해온다.
- 데이터 양이 적을 때는 나쁘지 않은 설계안이지만, 데이터가 아주 많아지면 데이터베이스가 병목될 수 있다.
<br/>


## 3단계. 상세 설계
### 트라이 자료구조
- 관계형 데이터베이스를 통해 가장 인기있는 5개 질의문을 조회할 때의 비효율을 해결하는 구조이다.
- 트라이란? 문자열들을 간략하게 저장할 수 있는 자료 구조다.
  - 트리 형태의 자료구조
  - 루트 노드는 빈 문자열을 난타낸다.
  - 각 노드는 글자 하나를 저장하며 26개의 자식 노드를 가질 수 있다.
  - 각 트리노드는 하나의 단어, 또는 접두어 문자열을 나타낸다.
- 기본 트라이 구조는 노드에 문자들을 저장하는데 이용 빈도에 따라 정렬된 결과를 내놓기 위해 노드에 빈도 정보까지 저장한다.
- 용어
  - p: 접두어 길이
  - n: 트라이 안에 있는 노드 개수
  - c: 주어진 노드의 자식 노드 개수
- 검색어가 be 일 때 가장 많이 사용된 질의어 2개 구하기
  1. 접두어 노드 be를 찾는다.
  2. 해당 노드부터 시작하는 하위 트리를 탐색하여 모든 유효 노드를 찾는다.
  3. 유효 노드를 정렬하여 2개만 골라낸다.
  - 시간 복잡도 O(p) + O(c) + O(clogc)
  - 직관적인 알고리즘이지만 최악의 경우, 전체 트라이를 다 검색해야 할 수 있다. 이 문제는 아래 방법으로 보완할 수 있다.
    - 접두어의 최대 길이를 제한 : 
      - 사용자가 검색창에 긴 검색어를 입력하는 일은 겅의 없으므로 p값은 작은 정수값으로 가정한다.
      - 검색어의 최대 길이를 제한 할 수 있다면 접두어 노드를 찾는 단계의 시간 복잡도는 O(작은 상수값=1)로 바뀐다.
    - 각 노드에 인기 검색어를 캐시 :
      - 각 노드에 k개의 인기 검색어를 저장해두면 전체 트라이를 검색할 필요 없다.
      - 하지만 각 노드에 질의어를 저장할 공간이 많이 필요하게 된다.
      - 그러나 빠른 응답속도가 아주 중요할 때는 이 정도 저장공간은 감수할 가치가 있다.
      - 마찬가지로 시간 복잡도가 O(1)로 줄어든다.
<br/>

### 데이터 수집 서비스
- 지금까지 살펴본 설계안은 사용자가 검색창에 뭔가 타이핑을 할 때마다 실시간으로 데이터를 수정했다.
- 이런 방법은 매일 수천만 건의 질의가 입력될 텐데 그때마다 트라이를 갱신하면 질의 서비스는 심각하게 느려지는 문제가 있고
- 일단 트라이가 만들어지고 나면 인기 검색어는 그다지 자주 바뀌지 않을 것이니 트라이는 그렇게 자주 갱신할 필요가 없다.
- 규모 확장이 쉬운 데이터 수집 서비스를 만드려면 데이터가 어디서 오고 어떻게 이용되는 지 알아야 한다.
- 트위터 같은 실시간 서비스가 아니라 구글 검색 같은 서비스는 검색어를 항상 신선하게 유지할 필요가 없다.
- 트라이를 만드는 데 쓰이는 데이터는 보통 분석 서비스나 로깅 서비스로부터 온다.
- 데이터 분석 서비스 로그 - 로그 취합서버 - 취합된 데이터 - 작업 서버 - 트라이 데이터 베이스 - 트라이 캐시
  - 데이터 분석 서비스 로그 : 검색된 원본 데이터와 발생 시각이 저장된다. 
  - 로그 취합 서버 : 대규모의 형식이 제각각인 로그들을 우리의 시스템 형태로 통일한다. (실시간 서비스라면 취합 주기를 짧게 한다.)
  - 취합된 데이터 : 검색된 원본 데이터, 해당 주기 시작 날짜, 해당 주기 동안 검색어의 빈도를 저장한다.
  - 작업 서버(worker) : 주기적으로 비동기 작업을 실행하는 서버 집합인데 트라이 자료구조를 만들고 트라이 데이터베이스에 저장한다.
  - 트라이 캐시 : 분산 캐시 시스템으로 트라이 데이터를 메모리에 유지하여 읽기연산 성능을 높인다. 주기 마다 데이터베이스으이 스냅샷을 떠서 갱신한다.
  - 트라이 데이터베이스 : 지속성 저장소다. 문서 저장소, 키-값 저장소를 데이터베이스로 사용할 수 있다.
    - 문서 저장소 : 새 트라이를 매주(주기) 만들기 때문에 주기적으로 트라이를 직렬화하여 데이터베이스에 저장할 수 있다. 몽고 디비 활용 가능
    - 키-값 저장소 : 트라이에 보관된 모든 접두어를 해시 테이블 키로 변환하고, 각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환한다.
<br/>

### 질의 서비스
1. 검색어가 로드밸런서로 전송된다.
2. 로드밸런서는 해당 질의를 api 서버로 보낸다.
3. api 서버는 트라이 캐시에서 데이터를 가져와 해당 요청에 대한 자동완성 검색어 제안 응답을 구성하낟.
4. 데이터가 트라이 캐시에 없는 경우에는 데이터를 데이터베이스에서 가져와 캐시에 채운다.
<br/>

** 최적화 방법
- ajax 요청 : 요청을 보내고 받기 위해 페이지를 새로고침 할 필요가 없다.
- 브라우저 캐싱 : 자동완성 검색에 대한 결과는 잛은 시간 안에 자주 바뀌지 않는다. 제안된 검색어들을 브라우저 캐시에 넣어두면 속도가 빨라진다.
- 데이터 샘플링 : 모든 질의 결과를 로깅하면 cpu 자원과 저장공간을 엄청나게 소진한다.n개 요청 가운데 1개만 로깅하도록 하는 방법이다.
<br/>


### 트라이 연산
- 트라이 생성 : 작업 서버가 담당. 데이터 분석 서비스 로그나 데이터베이스로부터 취합된 데이터를 이용한다.
- 트라이 갱신 :
  1) 매주 갱신 방법 : 새로운 트라이을 만들고 기존 트라이를 대체한다.
  2) 트라이의 각 노드를 개별적으로 갱신하는 방법. 트라이가 작을 때는 고려할 만 한 방법이다. 트라이 노드를 갱신할 때는 그 모든 상위 노드도 갱신해야 한다.
- 검색어 삭제 : 혐오, 폭력, 성적 검색어는 자동완성 결과에서 제거해야 한다. 트라이 캐시 앞에 필터 계층을 두고 부적절한 질의어가 반환되지 않도록 한다. 데이터베이스에서 해당 검색어를 물리적으로 삭제하는 것은 다음번 업데이트 사이클에서 비동기적으로 진행하면 된다.
<br/>

### 저장소 규모 확장
- 트라이의 크기가 한 서버에 넣기엔 너무 큰 경우에도 대응할 수 있도록 확장성 문제를 고려해보자.
- 영어만 지원하면 되기 때문에, 간단하게 첫 글자를 기준으로 샤딩할 수 있다.
  - 검색어를 보관하기 위해 2대의 서버가 필요하다면 a부터 m까지 시작하는 검색어는 첫 번째 서버에, 나머지는 두 번째 서버에 저장한다.🤔
  - 이 방법은 최대 26개 서버까지 제한된다.
  - 이 이상으로 서버를 늘리려면 샤딩을 계층ㅇ적으로 해야 한다.
  - 첫번 째 글자는 첫 번째 레벨에 샤딩
  - 두번 째 글자는 두 번째 레벨에 샤딩
  - aa~ag까지는 첫 번째 서버에, ah~an까지는 두 번째 서버어에, ao~au까지는 세번째 서버에, 나머지는 네 번째 서버에 보관
  - 그러나 각 알파벳으로 시작하는 단어 수가 균등하지 않아서 서버에 균등 배분하기 불가능하다.
- 이 문제를 해결하기 위해 과거 질의 데이터의 패턴을 분석하여 샤딩하는 방법이 있다.
  - 검색어 대응 샤딩 관리자는 어떤 검색어가 어느 저장소 서버에 저장되어 있는지에 대한 정보를 관리한다.🤔
<br/>
     

## 4단계. 마무리
** 추가 질문
- 다국어 지원이 가능하도록 확장하려면 어떻게 해야 할까요? 트라이에 유니코드 데이터를 저장해야 한다.
- 국가별로 인기 검색어 순위가 다르다면 어떻게 해야 할까요? 국가별로 다른 트라이를 사용하면 된다. 트라이를 cdn에 저장하여 응답속도를 높일 수 있다.
- 실시간으로 변하는 검색어의 추이를 반영하려면 어떻게 해야 하나요?
  - 새로운 뉴스가 생겨 특정 검색어의 인기가 갑자기 높아진다면?
  - 위 설계안은 작업서버가 매주 한 번 씩만 돌기 때문에 실시간 서비스에 부적합하다.
  - 설사 맞춰 작업서버가 실행되도, 트라이 구성에 시간이 많이 든다.
  - 아이디어
    - 샤딩을 통해 작업 대상 데이터의 양을 줄인다.
    - 순위 모델을 바꾸어 최근 검색어에 보다 높은 가중치를 준다.
    - 데이터가 스트림형태로 올 수 있다는 점을 고려해야 한다. (데이터가 지속적으로 생겨서 한번에 모든 데이터를 동시에 사용할 수 없을 가능성이 있다.)
    - 아파치 하둡 맵리듀스, 스파크 스트리밍, 아파치 스톰, 카프가 등이 필요하다.

